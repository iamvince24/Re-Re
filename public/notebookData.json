{
  "users": {
    "VjbWechgPjeVLnunOUcq87c3dVx1": {
      "notebooks": [
        {
          "chapters": [
            {
              "color": "red",
              "content": "# Introduction to Data Structure\n\nWe  study  data  structures  to  learn  to  write  more  efficient  programs.  But  what  is  the  point  of programs being efficient when new computers are faster day by day?  Because the more we are capable  of  excellence,  the  more  our  ambition  grows.  And  to  tackle  that,  we  need  to  learn  to represent and operate data more efficiently. By studying data structures, we will be able to store and use data more efficiently. In this chapter, we are going to explore the meaning of data structure as well as learn what different types of data structures there are.\n\n\nReference: https://www.studocu.com/row/document/american-international-university-bangladesh/data-structure/chapter-1-introduction-to-data-structure/10166774",
              "end": "2024-01-03",
              "id": 11111,
              "name": "Introduction",
              "start": "2024-01-02"
            },
            {
              "color": "blue",
              "content": "# Introduction\n\nAlgorithms are sets of instructions for solving a specific problem. They can be implemented using one or more data structures, and the efficiency of an algorithm depends on the chosen data structures and the steps taken to solve the problem. Some common algorithms include search algorithms, sorting algorithms, and graph algorithms.\n\n\nData structures and algorithms are important because they provide the foundation for many of the things we do on computers. Whether you are working on a small project or a large-scale software system, understanding data structures and algorithms can help you make the most of your resources and achieve the best possible performance.",
              "end": "2024-01-10",
              "id": 22222,
              "name": "Algorithms",
              "start": "2024-01-04"
            },
            {
              "color": "white",
              "content": "# Introduction\n\nIn this chapter, we continue to study implementations of the List interface, this time using pointer-based data structures rather than arrays. The structures in this chapter are made up of nodes that contain the list items. Using references (pointers), the nodes are linked together into a sequence. We first study singly-linked lists, which can implement Stack and (FIFO) Queue operations in constant time per operation and then move on to doubly-linked lists, which can implement Deque operations in constant time.",
              "end": "2024-01-15",
              "id": 33333,
              "name": "Linked Lists",
              "start": "2024-01-08"
            },
            {
              "color": "white",
              "content": "# Introduction\n\nA tree is a non-linear abstract data type with a hierarchy-based structure. It consists of nodes (where the data is stored) that are connected via links. The tree data structure stems from a single node called a root node and has subtrees connected to the root.",
              "end": "2024-01-20",
              "id": 44444,
              "name": "Tree",
              "start": "2024-01-11"
            },
            {
              "color": "yellow",
              "content": "# Introduction\n\nA graph is an abstract data type (ADT) that consists of a set of objects that are connected to each other via links. These objects are called vertices and the links are called edges.",
              "end": "2024-01-25",
              "id": 55555,
              "name": "Graphs",
              "start": "2024-01-18"
            }
          ],
          "color": "green",
          "end": "2024-01-25",
          "id": 11232,
          "name": "Data Structures",
          "start": "2024-01-02"
        },
        {
          "chapters": [
            {
              "color": "red",
              "content": "## 前言\n\n這系列是課程 [JavaScript Web Projects: 20 Projects to Build Your Portfolio](https://www.udemy.com/course/javascript-web-projects-to-build-your-portfolio-resume/) 的筆記，學習利用Javascript 做出各種互動網站。## 目標要做一個名言產生器，利用提供的json檔，搭配按鈕隨機抽選句子，並實作分享到twitter的按鈕。下面是這次要實作的畫面。範例的[連結](https://iamvince24.github.io/Quote-generator/)。![Image.png](https://res.craft.do/user/full/6e51b78d-bb10-9598-78bc-b1dd033f3f34/doc/5F39F35D-609F-4D23-B802-B043FB73FEDB/01895266-3920-45E1-BE25-980DE64FE9D1_2/AdzD9xZHxSyHb8pDmxGn1h52LVRXpWYurrfNnQBX3s8z/Image.png)",
              "end": "2024-01-20",
              "id": 14324,
              "name": "Project 1",
              "start": "2024-01-15"
            },
            {
              "color": "blue",
              "content": "## 前言\n\n這系列是課程 [JavaScript Web Projects: 20 Projects to Build Your Portfolio](https://www.udemy.com/course/javascript-web-projects-to-build-your-portfolio-resume/) 的筆記，學習利用 Javascript 做出各種互動網站。## 目標要實作出一個可以無限往下滑的網頁。\n\n下面是這次要實作的畫面。範例的[連結](https://iamvince24.github.io/infinity-scroll/)。![Image.png](https://res.craft.do/user/full/6e51b78d-bb10-9598-78bc-b1dd033f3f34/doc/5F39F35D-609F-4D23-B802-B043FB73FEDB/D890E200-C45B-440B-83AE-0E51138D5179_2/Dfq7h8xExuyNsiRYMEP0w7Td0ZPz76ui1mU8HbY2Utwz/Image.png)",
              "end": "2024-01-28",
              "id": 24344,
              "name": "Project 2",
              "start": "2024-01-20"
            },
            {
              "color": "white",
              "content": "## 前言\n\n\n這系列是課程 [JavaScript Web Projects: 20 Projects to Build Your Portfolio](https://www.udemy.com/course/javascript-web-projects-to-build-your-portfolio-resume/) 的筆記，學習利用 Javascript 做出各種互動網站。\n\n## 目標\n\n要實作出子母畫面的功能。\n\n下面是這次要實作的畫面。範例的[連結](https://iamvince24.github.io/Picture-In-Picture/)。\n\n![Picture-In-Picture.png](https://res.craft.do/user/full/6e51b78d-bb10-9598-78bc-b1dd033f3f34/doc/5F39F35D-609F-4D23-B802-B043FB73FEDB/286BCB87-C8D1-4C70-B588-82CEE36D293E_2/GhkDgNxq6VKJxPC29D38J49gfwdHsmK6MzYuM80zXDkz/Picture-In-Picture.png)",
              "end": "2024-02-04",
              "id": 34343,
              "name": "Project 3",
              "start": "2024-01-26"
            },
            {
              "color": "white",
              "content": "## 前言\n\n這系列是課程 [JavaScript Web Projects: 20 Projects to Build Your Portfolio](https://www.udemy.com/course/javascript-web-projects-to-build-your-portfolio-resume/) 的筆記，學習利用 Javascript 做出各種互動網站。\n\n\n## 目標\n\n這次會利用語音 API (Text-to-speech API) 跟 JokeAPI ，來實作讓電腦隨機說笑話。\n\n下面是這次要實作的畫面。範例的[連結](https://iamvince24.github.io/Joke-Teller/)。\n\n![Image.png](https://res.craft.do/user/full/6e51b78d-bb10-9598-78bc-b1dd033f3f34/doc/5F39F35D-609F-4D23-B802-B043FB73FEDB/10D5E0CE-1911-471D-8446-B33B00D57A63_2/OvkTp7pWi6EfoH0fG4mDJFYsPCyLIOC2rWKXpFQLYg8z/Image.png)\n",
              "end": "2024-02-10",
              "id": 44345,
              "name": "Project 4",
              "start": "2024-02-02"
            },
            {
              "color": "white",
              "content": "## 前言\n​\n這系列是課程 [JavaScript Web Projects: 20 Projects to Build Your Portfolio](https://www.udemy.com/course/javascript-web-projects-to-build-your-portfolio-resume/) 的筆記，學習利用 Javascript 做出各種互動網站。\n​\n​\n## 目標\n​\n實作 Light Dark Mode。\n​\n下面是這次要實作的畫面。範例的[連結](https://iamvince24.github.io/Light-Dark-Mode/)。\n​\n![截圖 2023-08-19 下午9.45.51.png](https://res.craft.do/user/full/6e51b78d-bb10-9598-78bc-b1dd033f3f34/doc/5F39F35D-609F-4D23-B802-B043FB73FEDB/A34DA9D4-9C24-4A03-AB67-14B737B028D0_2/Rp762XjZR9WNQiD3xwvd0FM4cY2OQ6ksZl2OcW0Oxt4z/%202023-08-19%209.45.51.png)\n​\n![截圖 2023-08-19 下午9.45.54.png](https://res.craft.do/user/full/6e51b78d-bb10-9598-78bc-b1dd033f3f34/doc/5F39F35D-609F-4D23-B802-B043FB73FEDB/DE4F8045-BE0B-4309-8509-9B97109948C1_2/NC3EkyzusyKLbZ0lvywX8g3y3cAacZeQEmrYRi44Sk4z/%202023-08-19%209.45.54.png)",
              "end": "2024-02-20",
              "id": 55454,
              "name": "Project 5",
              "start": "2024-02-11"
            }
          ],
          "color": "green",
          "end": "2024-02-20",
          "id": 25435,
          "name": "JavaScript Project",
          "start": "2024-01-15"
        },
        {
          "chapters": [
            {
              "color": "red",
              "content": "在大多數的應用程式中，可以分為以下三個部分。\n\n- State – the current data used in the app\n- View – the user interface displayed to users\n- Actions – events that a user can take to change the state\n\n而資料流的方式可以像是：\n\n1. State 會儲存 component 當下的資料。\n2. View 會顯示 component 當下的資料。\n3. 當使用者與 view 互動的時候，可能像是點擊按鈕之類的，state 將會以某種方式來更新。\n4. View 也會更新新的 state。\n\n若只以純粹的 React 來執行以上的流程，同時間會需要做很多事，不僅要渲染畫面，也要管理自己的 state，且當 action 改變 state 時，component 也需要彼此溝通這些變動，會讓以上這三種動作變得相當重疊且複雜。\n\n而 Redux 會藉由要求單一來源管理的 state 來協助分離這三個動作。更改 state 的請求以 action 的形式透過 component 傳送到某個單一來源。受這些變化影響的任何 component 都由這個單一來源來告知。而透過強加這種結構，Redux 讓程式更具可讀性、可靠性和可維護性。",
              "end": "2024-02-05",
              "id": 15853,
              "name": "Data Flow",
              "start": "2024-01-25"
            },
            {
              "color": "yellow",
              "content": "# 介紹 Redux 的 API\n\n## 前言與介紹什麼是 **Redux API ?**\n\n文章內容為 codecademy 的學習筆記。\n\nRedux 的應用程式是建立在 one-way flow 的資料模型之上，並由 store 管理。這邊會介紹一些內部功能：\n\n- State 是可以描述應用程式的資料集合，它用來渲染 UI。\n- 當使用者與 UI 互動的時候會發送 action 到 store。Action 是一個會把預計要做的事情傳送到 state 的一個物件。\n- **Store 會利用 reducer function，reducer function 會接收 action 以及 state 當作輸入 ，來產生下一個 state。**\n- 最後 UI 會基於新 store 的 state 來重新渲染，整個過程會再重新開始。\n\n這邊會專注在利用 Redux API 的 `createStore()` 以及相關的 `store` 來建立基礎的 Redux 應用程式。\n\n- `store.getState()`\n- `store.dispatch(action)`\n- `store.subscribe(listener)`\n\n而 `store.replaceReducer(nextReducer)` 是一個比較進階的方法，之後有機會再介紹。\n\n## 安裝 Redux Library\n\n**使用方式：**\n\n1. 在終端機使用 npm 來安裝 redux 。\n\n```other\nnpm install redux\n```\n\n2. 並在檔案中 import `createStore` 來使用。\n\n```other\nimport { createStore } from 'redux';\n```\n\n## 建立 Redux Store\n\n每個 Redux application 都會使用 reducer function 來說明要用哪些 action 去對 state 做更新，以及 action 會怎麼到下一個 state。\n\n可以看看下面舉例的使用方式：\n\n```javascript\nconst initialState = 'on';\nconst lightSwitchReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'toggle':\n      return state === 'on' ? 'off' : 'on';\n    default:\n      return state;\n  }\n}\n\nlet state = 'on';\nstate = lightSwitchReducer(state, { type: 'toggle' });\n\nconsole.log(state); // Prints 'off'\n```\n\n### `createStore()`\n\n而 Redux 有一個很好用的 helper function 叫做 `createStore()` ，它可以用來創建 store object，且只接收一個 reducer function 做為參數。\n\n比如以下例子：\n\n```javascript\nimport { createStore } from 'redux'\n \nconst initialState = 'on';\nconst lightSwitchReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'toggle':\n      return state === 'on' ? 'off' : 'on';\n    default:\n      return state;\n  }\n}\n \nconst store = createStore(lightSwitchReducer);\n```\n\n## Dispatch Actions to the Store\n\n這裡介紹一些利用 `createStore()` 所回傳的 store object 延伸的使用方法，可以用來與它的 state 以及 reducer function 做互動。\n\n### `store.dispatch()`\n\n這是最常被使用的方法，它用來把 action 發送到 store object，表示說你希望去更新此 state。而它唯一個參數是一個 action object，這個 object 是 type 屬性，用來描述 state 的變化。\n\n```javascript\nconst action = { type: 'actionDescriptor' }; \nstore.dispatch(action);\n```\n\n當 `action.type` 被 reducer 確認後，state 才會被更新與回傳。\n\n以下來看看使用方式：\n\n```javascript\nimport { createStore } from 'redux';\n \nconst initialState = 'on';\nconst lightSwitchReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'toggle':\n      return state === 'on' ? 'off' : 'on';\n    default:\n      return state;\n  }\n}\n \nconst store = createStore(lightSwitchReducer);\n \nconsole.log(store.getState()); // Prints 'on'\n\nstore.dispatch({ type: 'toggle' }); \nconsole.log(store.getState()); // Prints 'off'\n \nstore.dispatch({ type: 'toggle' });\nconsole.log(store.getState()); // Prints 'on'\n```\n\n當 store 執行 reducer function 時，內部的 state 其實是 `store.getState()` 。\n\n## Action Creators\n\n若需要很多次的 `store.dispatch()`，因為需要一直重複，可能比較容易造成錯誤。這時可以透過 action creator 來回傳 type 屬性，使得程式可以簡化。\n\n```javascript\nconst toggle = () => {\n  return { type: \"toggle\" };\n}\nstore.dispatch(toggle()); // Toggles the light to 'off'\nstore.dispatch(toggle()); // Toggles the light back to 'on'\nstore.dispatch(toggle()); // Toggles the light back to 'off'\n```\n\n## Respond to State Changes\n\n若要觸發 DOM events 來與使用者互動，可以使用 event listener ，這邊當然也可以。\n\n### `store.subscribe()`\n\n也就是說 action 發送給 store 的動作可以使用 `store.subscribe()` 的方法來監聽跟觸發。它只接收一個 listener function 參數，用來做改變 store’s state 的動作。\n\n```javascript\nconst reactToChange = () => console.log('change detected!');\nstore.subscribe(reactToChange);\n```\n\n在這個例子中，每當 action 發送給 store 時，state 就會發生變化，而 `reactToChange()` 這個 listener 就會被執行。而有時候它會用來阻止 listener 響應 store，因此 `store.subscribe()` 也可以返回一個 `unsubscribe` function 來停止相關動作。\n\n一樣舉個例子來看看：\n\n```javascript\n// lightSwitchReducer(), toggle(), and store omitted...\n \nconst reactToChange = () => {\n  console.log(`The light was switched ${store.getState()}!`);\n}\nconst unsubscribe = store.subscribe(reactToChange);\n \nstore.dispatch(toggle());\n// reactToChange() is called, printing:\n// 'The light was switched off!'\n \nstore.dispatch(toggle());\n// reactToChange() is called, printing:\n// 'The light was switched on!'\n \nunsubscribe(); \n// reactToChange() is now unsubscribed\n \nstore.dispatch(toggle());\n// no print statement!\n \nconsole.log(store.getState()); // Prints 'off'\n```\n\n在前兩個 action 發送後，藉由呼叫 `unsubscribe` 來讓 `reactToChange()` 取消對 store 做響應。\n\n## Connect the Redux Store to a UI\n\n要將 Redux store 串接到 UI 需要以下幾個步驟：\n\n1. 創建 Redux store。\n2. 渲染最初的 state。\n3. Subscribe to updates，在 the subscription callback 裡：\n   - 取得 the current store state。\n   - 選擇 UI 所需要的 data。\n   - 用 data 去更新 UI。\n4. 藉由 Redux actions 去響應 UI events。\n\n以下舉個例子，創建 index.html 跟 store.js 檔案來做範例：\n\n```javascript\n<p id='counter'>Waiting for current state.</p>\n<button id='incrementer'>+</button>\n<button id='decrementer'>-</button>\n```\n\n大概說明一下 store.js 裡面的 function：\n\n- `counterElement`, `incrementer`, and `decrementer` : 用來取得 DOM 元素。\n- `render` : 用於響應 store state 做監聽。\n- `incrementerClicked` and `decrementerClicked`: DOM event handlers 為使用者與按鈕的互動做響應。\n\n```javascript\nimport { createStore } from 'redux'\n\nconst { createStore } = require('redux');\n\n// Action Creators\nfunction increment() { \n  return {type: 'increment'}\n}\n\nfunction decrement() { \n  return {type: 'decrement'}\n}\n\n// Reducer / Store\nconst initialState = 0;\nconst countReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'increment':\n      return state + 1; \n    case 'decrement':\n      return state - 1; \n    default:\n      return state;\n  }\n};  \nconst store = createStore(countReducer);\n\n// HTML Elements\nconst counterElement = document.getElementById('counter');\nconst incrementer = document.getElementById('incrementer');\nconst decrementer = document.getElementById('decrementer');\n\n// Store State Change Listener\nconst render = () => {\n  counterElement.innerHTML = store.getState();\n}\n\nrender();\nstore.subscribe(render);\n\n// DOM Event Handlers\nconst incrementerClicked = () => {\n  store.dispatch(increment())\n}\nincrementer.addEventListener('click', incrementerClicked);\n \nconst decrementerClicked = () => {\n  store.dispatch(decrement())\n}\ndecrementer.addEventListener('click', decrementerClicked);\n```\n\n### React and Redux\n\n這邊更具體的說明一下 Redux 與 React 串接的常見步驟。\n\n- `render()` function 會被同意去渲染 top-level React component 。\n- 而 React component 會接收 `store.getState()` 目前的 value 當作 prop，並利用這筆資料來渲染 UI。\n- 附加在 React component 上的 event listeners 會發送 actions 到 store去。\n\n這邊舉個 light switch 應用的例子做說明：\n\n- `render()` function 會被註冊到 store。\n- `store.getState()` 會作為 prop 當成 state 傳送到 `<LightSwitch />` component。\n- 這個 `LightSwitch` component 會顯示 the current store state，可能是 `'on'` 或是 `'off'` ，而去相應地改變顏色。\n- `LightSwitch` component 會宣告一個 click 監聽來發送 `toggle()` action 到 store 中。\n\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore } from 'redux';\n\n// REDUX CODE\n///////////////////////////////////\n\nconst toggle = () => {\n  return {type: 'toggle'} \n}\n \nconst initialState = 'off';\nconst lightSwitchReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'toggle':\n      return state === 'on' ? 'off' : 'on';\n    default:\n      return state; \n  }\n} \n \nconst store = createStore(lightSwitchReducer);\n\n// REACT CODE\n///////////////////////////////////\n \n// Pass the store's current state as a prop to the LightSwitch component.\nconst render = () => {\n  ReactDOM.render(\n    <LightSwitch \n      state={store.getState()}\n    />,\n    document.getElementById('root')\n  )\n}\n \nrender(); // Execute once to render with the initial state.\nstore.subscribe(render); // Re-render in response to state changes.\n\n// Receive the store's state as a prop.\nfunction LightSwitch(props) {\n  const state = props.state; \n\n  // Adjust the UI based on the store's current state.\n  const bgColor = state === 'on' ? 'white' : 'black';\n  const textColor = state === 'on' ? 'black' : 'white';  \n \n  // The click handler dispatches an action to the store.\n  const handleLightSwitchClick = () => {\n    store.dispatch(toggle());\n  }\n \n  return (  \n    <div style={{background : bgColor, color: textColor}}>\n      <button onClick={handleLightSwitchClick}>\n        {state}\n      </button>\n    </div>\n  )\n}\n```\n\n## 文章參考\n\n[Learn Redux](https://www.codecademy.com/learn/learn-redux)\n\n",
              "end": "2024-02-10",
              "id": 21239,
              "name": "Redux 的 API",
              "start": "2024-02-04"
            },
            {
              "color": "white",
              "content": "建立 Redux Store 的過程包括以下步驟：\n\n安裝 Redux 庫，使用指令 npm install redux。\n\n創建 Reducer，它是一個純函數，定義應用程式狀態的修改邏輯。可以有多個 Reducer，通常組合成一個根 Reducer。\n\n如果有多個 Reducer，使用 Redux 的 combineReducers 函數將它們組合成一個根 Reducer。\n\n使用 createStore 函數建立 Store，將根 Reducer 傳遞給它。也可以設定 Redux DevTools 擴充套件。\n\n在 React 應用程式中整合 Store，使用 Redux 的 Provider 包裹最外層組件，並將 Store 作為屬性傳遞給 Provider。\n\n現在，應用程式已經整合了 Redux Store，可以使用 React-Redux 提供的 connect 函數將 React 組件連接到 Redux Store，實現對應用程式狀態的存取和更新。",
              "end": "2024-02-15",
              "id": 34238,
              "name": "建立 Redux Store",
              "start": "2024-02-09"
            },
            {
              "color": "white",
              "content": "1. **單一資料來源：**\n   Redux 強調應用程式的整體狀態應該被保存在一個單一的資料來源，也就是Redux Store中。這有助於簡化狀態的管理和追蹤。\n\n2. **不可變性（Immutability）：**\n   Redux 鼓勵使用不可變的數據結構，這表示一旦狀態被設定，就不能直接修改它。每次狀態發生變化時，都會返回一個新的狀態對象，而不是修改現有的狀態對象。這有助於追蹤狀態的變化，使得時間旅行除錯（Time Travel Debugging）成為可能。\n\n3. **純函數的Reducers：**\n   Redux 的Reducer必須是純函數。純函數是指在相同輸入下總是產生相同輸出，而且不會有任何副作用。Reducers接收一個先前的狀態和一個action，返回一個新的狀態，這種設計讓狀態的修改變得可預測和容易理解。\n\n4. **單向數據流：**\n   在Redux中，數據的流動是單向的。應用程式狀態只能通過發送action來進行修改，Reducers處理這些action並返回新的狀態。這種單向數據流的架構使得應用程式的行為更可控，容易追蹤和理解。\n\n5. **中央化管理：**\n   Redux Store提供了一個中央化的地方來管理整個應用程式的狀態。這使得不同組件能夠輕鬆共享和存取應用程式的狀態，而不需要透過繁瑣的層層傳遞。\n",
              "end": "2024-02-21",
              "id": 44329,
              "name": "對 State 的策略",
              "start": "2024-02-15"
            },
            {
              "color": "white",
              "content": "現在可以想想使用者要如何透過 actions 的觸發機制，去改變 slices of state。\n\n> 提醒一下，actions 在 Redux 中常被表示為擁有 type property 的 JavaScript objects，也常使用 `store.dispatch()` 來發送給 store。\n\n當一個 application state 有很多 slices，每一個 actions 通常一次只改變一個 slice。因此會建議每個 action's type 可以 follow  `'sliceName / actionDescriptor'` 這樣的格式，來確認說哪一個 slice of state 應該要更新。\n\n舉例來說，todo app 有一個 `state.todo` slice，那它用來新增事項的 action type 就可以設為 `'todos/addTodo’`。\n\n#### 設定 Recipes action：\n\n   1. `'allRecipes/loadData'` : 當 application 啟動時，此 action 會被派去從 API 抓取所需的資料。\n   2. `'favoriteRecipes/addRecipe'` : 當使用者點擊 ❤️ icon 時，會把食譜加入最愛。\n   3. `'favoriteRecipes/removeRecipe'` : 當使用者點擊 💔  icon 時，會把食譜從最愛中移出。\n   4. `'searchTerm/setSearchTerm'` : 當使用者透過改變搜尋框內的文字去篩選食譜時觸發。\n   5. `'searchTerm/clearSearchTerm'` : 當使用者點擊在搜尋框旁的 ‘X’ 按鈕時觸發。",
              "end": "2024-02-25",
              "id": 54329,
              "name": "For Complex State",
              "start": "2024-02-20"
            },
            {
              "color": "white",
              "content": "Redux 很適合處理多功能的複雜 application，且它的功能都有一些與狀態相關的資料需要管理。在這種狀況下，通常會用 object 來代表整個 store's state 的資料型別。\n\n舉例一個 todo app，它可以讓使用者做以下的動作：\n\n   1. 增加 todo list。\n   2. 為每個 todo 事項標記完成或未完成。\n   3. 可以選擇只顯示完成事項、未完成事項或是全部顯示。",
              "end": "2024-03-01",
              "id": 64329,
              "name": "Slices",
              "start": "2024-02-24"
            }
          ],
          "color": "green",
          "end": "2024-03-01",
          "id": 32343,
          "name": "Redux",
          "start": "2024-01-25"
        }
      ],
      "username": "Test user"
    },
    "eDkqRFxYIWQPDLi7ptBC2Kb09bp1": {
      "notebooks": [
        {
          "chapters": [
            {
              "color": "white",
              "content": "# Defining Your UX Research Problem\n- 80% of all customer research serves only to reinforce what companies already know, rather than testing or developing new possibilities.\n\n## Find out what stakeholders need to know\n- In our experience, members of a development team are always pleased to be consulted, and value the opportunity to contribute.\n\n## Deconstruct the Construct\n- Deconstruct the phenomenon that is being investigated.\n- We have to deconstruct them to reveal their constitute elements and then find ways to operationalize those elements.\n\n## Mesure Something\n\n## Shake Out the Issues\n\n---\n\n## Setting the Stage\n\n- The Seven Deadly Sins of UX Research\n\n- Think like a detective\n\n- The two questions we answer with UX research\n\n- Anatomy of a research question\n\n- Applying psychology to UX research\n\n- Why iterative design isn't enough to create innovative products\n\n- Does your company deliver a superior customer experience?\n\n## Planning User Experience Research\n\n- **Defining your UX research problem**\n\n   - “If I have 20 days to solve a problem, I would take 19 days to define it.“ Albert Einstein\n\n   - 80% of all customer research serves only to reinforce what companies already know, rather than testing or developing new possibilities.\n\n      - Find out what stakeholders need to know\n\n           - In our experience, members of a development team are always pleased to be consulted, and value the opportunity to contribute.\n\n      - Deconstruct the Construct\n\n         - Deconstruct the phenomenon that is being investigated.\n         - We have to deconstruct them to reveal their constitute elements and then find ways to operationalize those elements.\n\n      - Measure Something\n\n      - Shake Out the Issues\n\n\n\n   - How to approach desk research\n\n   - Conducting an effective stakeholder interview\n\n   - Identifying the user groups for your UX research\n\n   - Writing the perfect participant screener\n\n   - Arguments against a representative sample\n\n   - How to find more usability problems with fewer participants\n\n   - Deciding on your first research activity with users ",
              "end": "2024-01-29",
              "id": "15433",
              "name": "planning ux research",
              "start": "2024-01-18"
            },
            {
              "color": "white",
              "content": "Type something abd",
              "end": "2024-01-20",
              "id": 44180,
              "name": "Table of Content",
              "start": "2024-01-19"
            },
            {
              "color": "white",
              "content": "Type something",
              "end": "2024-01-20",
              "id": 77498,
              "name": "Setting the Stage",
              "start": "2024-01-19"
            },
            {
              "color": "white",
              "content": "Type something",
              "end": "2024-01-20",
              "id": 9734,
              "name": "Conducting user experience research",
              "start": "2024-01-19"
            }
          ],
          "color": "white",
          "end": "2024-01-29",
          "id": 12312,
          "name": "think like a ux researcher",
          "start": "2024-01-18"
        },
        {
          "chapters": [
            {
              "color": "white",
              "content": "Type something",
              "end": "2024-01-20",
              "id": 99614,
              "name": "Default Chapter",
              "start": "2024-01-19"
            }
          ],
          "color": "yellow",
          "end": "2024-01-20",
          "id": 99614,
          "name": "Think Like ",
          "start": "2024-01-19"
        }
      ],
      "username": "Nobi Yo"
    }
  }
}
